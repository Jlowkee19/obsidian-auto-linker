/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => AutoLinkerPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian = require("obsidian");
var import_obsidian2 = require("obsidian");
var AutoLinkerSuggest = class extends import_obsidian.EditorSuggest {
  constructor(plugin) {
    super(plugin.app);
    this.plugin = plugin;
  }
  onTrigger(cursor, editor, file) {
    const line = editor.getLine(cursor.line);
    const beforeCursor = line.substring(0, cursor.ch);
    const linkMatch = beforeCursor.match(/\[\[([^\]]*?)$/);
    if (linkMatch) {
      return {
        end: cursor,
        start: {
          line: cursor.line,
          ch: cursor.ch - linkMatch[1].length
        },
        query: linkMatch[1]
      };
    }
    const wordMatch = beforeCursor.match(/(\S+)$/);
    if (wordMatch && wordMatch[1].length >= 2) {
      return {
        end: cursor,
        start: {
          line: cursor.line,
          ch: cursor.ch - wordMatch[1].length
        },
        query: wordMatch[1]
      };
    }
    return null;
  }
  getSuggestions(context) {
    const query = context.query.toLowerCase();
    if (query.length < 2)
      return [];
    const suggestions = [];
    const files = this.app.vault.getMarkdownFiles();
    for (const file of files) {
      if (file === context.file)
        continue;
      const fileName = file.basename.toLowerCase();
      if (fileName.includes(query)) {
        suggestions.push({
          title: file.basename,
          file,
          type: "note",
          displayText: `\u{1F4C4} ${file.basename}`,
          linkText: file.basename
        });
      }
      const cache = this.app.metadataCache.getFileCache(file);
      if (cache) {
        if (cache.headings) {
          for (const heading of cache.headings) {
            if (heading.heading.toLowerCase().includes(query)) {
              suggestions.push({
                title: heading.heading,
                file,
                type: "heading",
                displayText: `${"#".repeat(heading.level)} ${heading.heading} (${file.basename})`,
                linkText: `${file.basename}#${heading.heading}`
              });
            }
          }
        }
        if (cache.blocks) {
          const fileContent = this.app.vault.cachedRead(file);
          fileContent.then((content) => {
            const lines = content.split("\n");
            for (const [blockId, block] of Object.entries(cache.blocks)) {
              const blockLine = lines[block.position.start.line];
              if (blockLine && blockLine.toLowerCase().includes(query)) {
                suggestions.push({
                  title: blockLine.trim(),
                  file,
                  type: "block",
                  displayText: `\u{1F517} ${blockLine.trim().substring(0, 50)}... (${file.basename})`,
                  linkText: `${file.basename}#^${blockId}`
                });
              }
            }
          });
        }
      }
    }
    return suggestions.sort((a, b) => {
      const aExact = a.title.toLowerCase() === query;
      const bExact = b.title.toLowerCase() === query;
      if (aExact && !bExact)
        return -1;
      if (!aExact && bExact)
        return 1;
      return a.title.localeCompare(b.title);
    }).slice(0, 10);
  }
  renderSuggestion(suggestion, el) {
    el.createEl("div", { text: suggestion.displayText });
  }
  selectSuggestion(suggestion, evt) {
    var _a, _b, _c;
    const editor = (_a = this.context) == null ? void 0 : _a.editor;
    if (!editor)
      return;
    const cursor = editor.getCursor();
    const line = editor.getLine(cursor.line);
    const start = (_b = this.context) == null ? void 0 : _b.start;
    const end = (_c = this.context) == null ? void 0 : _c.end;
    if (start && end) {
      const beforeStart = line.substring(0, start.ch);
      const isInLinkContext = beforeStart.endsWith("[[");
      let replacement;
      if (isInLinkContext) {
        replacement = suggestion.linkText + "]]";
      } else {
        replacement = `[[${suggestion.linkText}]]`;
      }
      editor.replaceRange(replacement, start, end);
    }
  }
};
var AutoLinkerPlugin = class extends import_obsidian.Plugin {
  async onload() {
    console.log("Loading Auto Linker Plugin");
    this.suggester = new AutoLinkerSuggest(this);
    this.registerEditorSuggest(this.suggester);
    this.addSettingTab(new AutoLinkerSettingTab(this.app, this));
    this.addCommand({
      id: "trigger-link-suggestions",
      name: "Trigger link suggestions",
      editorCallback: (editor) => {
        const cursor = editor.getCursor();
        const line = editor.getLine(cursor.line);
        const beforeCursor = line.substring(0, cursor.ch);
        if (!beforeCursor.endsWith("[[")) {
          editor.replaceRange("[[", cursor);
        }
      }
    });
    new import_obsidian.Notice("Auto Linker Plugin loaded successfully!");
  }
  onunload() {
    console.log("Unloading Auto Linker Plugin");
  }
};
var AutoLinkerSettingTab = class extends import_obsidian2.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Auto Linker Settings" });
    new import_obsidian2.Setting(containerEl).setName("Minimum query length").setDesc("Minimum number of characters to trigger suggestions").addSlider(
      (slider) => slider.setLimits(1, 5, 1).setValue(2).setDynamicTooltip()
    );
    new import_obsidian2.Setting(containerEl).setName("Maximum suggestions").setDesc("Maximum number of suggestions to show").addSlider(
      (slider) => slider.setLimits(5, 20, 1).setValue(10).setDynamicTooltip()
    );
    containerEl.createEl("h3", { text: "How to use" });
    containerEl.createEl("p", { text: "\u2022 Type [[ to trigger link suggestions" });
    containerEl.createEl("p", { text: "\u2022 Start typing any text to see auto-suggestions" });
    containerEl.createEl("p", { text: "\u2022 Use arrow keys to navigate and Enter to select" });
    containerEl.createEl("p", { text: "\u2022 Suggestions include note titles, headings, and blocks" });
  }
};
